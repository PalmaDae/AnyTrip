package org.example.tgBot.handlers;

import org.example.DTO.SheduleRequest;
import org.example.RaspRequestBuilder;
import org.example.tgBot.util.Keyboard;
import org.example.tgBot.util.TgMessages;
import org.example.util.ClosedStrings;
import org.example.util.TransportTypes;
import org.example.util.–°onditionsRequests;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;

import static org.example.util.TransportTypes.listTransportTypes;

public class MessageHandler implements IHandler {
    private final TelegramClient telegramClient;
    private final Keyboard keyboard;
    private SheduleRequest sheduleRequest;

    public MessageHandler(TelegramClient telegramClient) {
        this.telegramClient = telegramClient;
        this.keyboard = new Keyboard(telegramClient);
    }

    @Override
    public boolean canHandle(Update update) {
        return false;
    }

    public void tryTo(SendMessage sendMessage) {
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private static SendMessage newTextMessage(String messageText, long chatId) {
        return SendMessage.builder()
                .chatId(chatId)
                .text(messageText)
                .build();
    }

    @Override
    public void handle(Update update) {
        long chatId = update.getMessage().getChatId();
        String messageText = update.getMessage().getText();

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π –æ–∂–∏–¥–∞–Ω–∏—è –≤–≤–æ–¥–∞
        if (!(update.hasCallbackQuery()) & handleInputStates(chatId, messageText) ) {
            return;
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥
        handleCommands(chatId, messageText);
    }

    private boolean handleInputStates(long chatId, String messageText) {

        if (–°onditionsRequests.WAIT_INPUT_CODE) {
            handleForCity1(chatId, messageText);
            return true;
        }
        if (–°onditionsRequests.WAIT_TWO_CITIES) {
            handleForCity2(chatId, messageText);
            return true;
        }

        if (–°onditionsRequests.WAIT_INPUT_TRANSPORT) {
            handleTransport(chatId, messageText);
            return true;
        }
        if (–°onditionsRequests.WAIT_INPUT_DATE) {
            handleDate(chatId, messageText);
            return true;
        }
        return false;
    }

    private void handleCommands(long chatId, String messageText) {
        TgMessages tgMessages = TgMessages.getCommand(messageText);
        SendMessage sendMessage = null;

        switch (tgMessages) {
            case START:
                sendMessage = newTextMessage("–°—Ç–∞—Ä—Ç—É–µ–º!", chatId);
                break;

            case KEYBOARD:
                sendMessage = createKeyboardMessage(chatId);
                break;

            case HELP:
                sendMessage = newTextMessage("–í–≤–µ–¥–∏—Ç–µ '–ü–æ–∏—Å–∫ –º–∞—Ä—à—Ä—É—Ç–∞', –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º", chatId);
                break;

            case FAVORITE_TRIPS:
                handleFavoriteTrips(chatId);
                break;

            case HISTORY_OF_TRIPS:
                try {
                    sendMessage = keyboard.newTextMessageRemoveKeyboard(
                            "There is you can find your history of trips", chatId, true);
                } catch (TelegramApiException e) {
                    throw new RuntimeException(e);
                }
                break;

            case SEARCH_OF_TRIPS:
                startTripSearch(chatId);
                return;

            case STATION_CODE:
                sendMessage = newTextMessage("–∫–æ–¥ –≤–≤–µ–¥–µ–Ω", chatId);
                break;

            default:
                sendMessage = newTextMessage(messageText, chatId);
        }

        if (sendMessage != null) {
            tryTo(sendMessage);
        }
    }

    private SendMessage createKeyboardMessage(long chatId) {
        SendMessage message = newTextMessage("–ì–ª—è–¥–∏ –∏ –ª—é–±—É–π—Å—è!", chatId);
        message.setReplyMarkup(ReplyKeyboardMarkup.builder()
                .keyboardRow(new KeyboardRow("–ò–∑–±—Ä–∞–Ω–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã"))
                .keyboardRow(new KeyboardRow("–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ä—à—Ä—É—Ç–æ–≤"))
                .keyboardRow(new KeyboardRow("–ü–æ–∏—Å–∫ –º–∞—Ä—à—Ä—É—Ç–∞"))
                .build());
        return message;
    }

    private void handleFavoriteTrips(long chatId) {
        try {
            keyboard.sendInlineKeyboard(chatId);
        } catch (TelegramApiException e) {
            throw new RuntimeException(e);
        }
    }

    private void startTripSearch(long chatId) {
        InlineKeyboardMarkup keyboardMarkup = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(InlineKeyboardButton
                        .builder()
                        .text("–û—Ç–º–µ–Ω–∏—Ç—å –≤–≤–æ–¥")
                        .callbackData("Some_remove")
                        .build()))
                .build();

        SendMessage message = SendMessage.builder()
                .chatId(chatId)
                .text("üîç –í–≤–µ–¥–∏—Ç–µ 1-–π –≥–æ—Ä–æ–¥")
                .replyMarkup(keyboardMarkup)
                .build();

        –°onditionsRequests.WAIT_INPUT_SHEDULE = true;
        –°onditionsRequests.WAIT_INPUT_CODE = true;
        this.sheduleRequest = new SheduleRequest(true);

        tryTo(message);
    }

    // –≤–æ—Ç –∑–¥–µ—Å—å –≤–≤–æ–¥ –≥–æ—Ä–æ–¥–∞ —Ç–µ–ø–µ—Ä—å
    private void handleForCity1(long chatId, String codeText) {
        if (!–°onditionsRequests.WAIT_INPUT_SHEDULE) return;
        sheduleRequest.setCity1(codeText);
        –°onditionsRequests.WAIT_INPUT_CODE = false;


//        –°onditionsRequests.WAIT_INPUT_TRANSPORT = true;
        –°onditionsRequests.WAIT_TWO_CITIES = true;
        tryTo(newTextMessage("üîç –í–≤–µ–¥–∏—Ç–µ 2-–π –≥–æ—Ä–æ–¥\n", chatId));

    }

    private void handleForCity2(long chatId, String codeText) {
        if (!–°onditionsRequests.WAIT_INPUT_SHEDULE) return;

        sheduleRequest.setCity2(codeText);


        –°onditionsRequests.WAIT_INPUT_TRANSPORT = true;
        –°onditionsRequests.WAIT_TWO_CITIES = false;
        tryTo(newTextMessage("–î–æ—Å—Ç—É–ø–Ω—ã–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç:\n\n–°–∞–º–æ–ª—ë—Ç\n–ü–æ–µ–∑–¥\n–≠–ª–µ–∫—Ç—Ä–∏—á–∫–∞\n–ê–≤—Ç–æ–±—É—Å\n–ú–æ—Ä—Å–∫–æ–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç\n–†–µ—á–Ω–æ–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç\n–í–µ—Ä—Ç–æ–ª—ë—Ç", chatId));

    }

    private void handleTransport(long chatId, String transportText) {
        if (!–°onditionsRequests.WAIT_INPUT_SHEDULE) return;

        transportText = transportText.toUpperCase();

        switch (transportText) {
            case "–ê–í–¢–û–ë–£–°":
                transportText = "bus";
                break;
            case "–≠–õ–ï–ö–¢–†–ò–ß–ö–ê":
                transportText = "suburban";
                break;
            case "–ü–û–ï–ó–î":
                transportText = "train";
                break;
            case "–°–ê–ú–û–õ–Å–¢":
            case "–°–ê–ú–û–õ–ï–¢":
                transportText = "plane";
                break;
            case "–í–ï–†–¢–û–õ–Å–¢":
            case "–í–ï–†–¢–û–õ–ï–¢":
                transportText = "helicopter";
                break;
        }

        transportText = transportText.toUpperCase();

        try {
            TransportTypes transport = TransportTypes.valueOf(transportText);
            if (listTransportTypes.contains(transport)) {
                sheduleRequest.setTransport(transportText);
                –°onditionsRequests.WAIT_INPUT_TRANSPORT = false;
                –°onditionsRequests.WAIT_INPUT_DATE = true;
                tryTo(newTextMessage("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:", chatId));
            } else {
                tryTo(newTextMessage("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞. –í–≤–µ–¥–∏—Ç–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ:", chatId));
            }
        } catch (IllegalArgumentException e) {
            tryTo(newTextMessage("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞. –í–≤–µ–¥–∏—Ç–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ:", chatId));
        }
    }

    private void handleDate(long chatId, String dateText) {
        if (!validateScheduleState(chatId)) return;

//        if (Pattern.matches("\\d{4}-\\d{2}-\\d{2}", dateText)) {
            sheduleRequest.setDate(dateText);
            –°onditionsRequests.WAIT_INPUT_DATE = false;
            // –í–û–¢ –ó–î–ï–°–¨ ....................
            tryTo(newTextMessage("–î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ: \n" + RaspRequestBuilder.getInString(RaspRequestBuilder.buildSearchRequests(sheduleRequest.getCity1(), sheduleRequest.getCity2(), sheduleRequest.getTransport(), sheduleRequest.getDate(), ClosedStrings.API_KEY)) , chatId));
//        } else {
//            tryTo(newTextMessage("–î–∞—Ç–∞ –≤–≤–µ–¥–µ–Ω–∞ –Ω–µ–≤–µ—Ä–Ω–æ. –í–≤–µ–¥–∏—Ç–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:", chatId));
//        }
    }

    private boolean validateScheduleState(long chatId) {
        if (!–°onditionsRequests.WAIT_INPUT_SHEDULE) {
            –°onditionsRequests.resetAllFieldsOnFalse();
            tryTo(newTextMessage("–°–µ—Å—Å–∏—è –ø–æ–∏—Å–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.", chatId));
            return false;
        }
        return true;
    }
}